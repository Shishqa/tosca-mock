version: "1.0"
metadata:
  history:
    - description: compile
      timestamp: "2023-03-16T11:33:19.337586563+03:00"
  puccini:
    scriptlets:
      tosca:
        coerce: |-
          const traversal = require('tosca.lib.traversal');
          const tosca = require('tosca.lib.utils');

          traversal.coerce();
          if (puccini.arguments.history !== 'false')
            tosca.addHistory('coerce');
          puccini.write(clout);
        comparer:
          version: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.2.2
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.2.2
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.2.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.2.2

            exports.compare = function(a, b) {
              if (a.$comparer !== b.$comparer)
                throw 'both values must be of type "version"';
              if (a.major !== b.major)
                return a.major < b.major ? -1 : 1;
              if (a.minor !== b.minor)
                return a.minor < b.minor ? -1 : 1;
              if (a.fix !== b.fix)
                return a.fix < b.fix ? -1 : 1;
              let aq = a.qualifier.toLowerCase();
              let bq = b.qualifier.toLowerCase();
              if (aq !== bq) // note: the qualifier is compared alphabetically, *not* semantically
                return aq < bq ? -1 : 1;
              if (a.build !== b.build)
                return a.build < b.build ? -1 : 1;
              return 0;
            };
        constraint:
          _format: |-
            exports.validate = function(v, format) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              if (!puccini.isType(v, 'ard.string'))
                return 'not a string';
              try {
                puccini.validateFormat(v, format);
              } catch (x) {
                if (x.value && x.value.error)
                  // Unwrap Go error
                  return x.value.error();
                else
                  throw x;
              }
              return true;
            };
          equal: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v1, v2) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              return tosca.compare(v1, v2) === 0;
            };
          greater_or_equal: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v1, v2) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              return tosca.compare(v1, v2) >= 0;
            };
          greater_than: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v1, v2) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              return tosca.compare(v1, v2) > 0;
            };
          in_range: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v, lower, upper) {
              if (arguments.length !== 3)
                throw 'must have 2 arguments';
              if ((v.lower !== undefined) && (v.upper !== undefined))
                // Special case: is the range in range?
                return (tosca.compare(v.lower, lower) >= 0) && (tosca.compare(v.upper, upper) <= 0);
              else
                return (tosca.compare(v, lower) >= 0) && (tosca.compare(v, upper) <= 0);
            };
          length: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v, length) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              return tosca.getLength(v) == length;
            };
          less_or_equal: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v1, v2) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              return tosca.compare(v1, v2) <= 0;
            };
          less_than: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v1, v2) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              return tosca.compare(v1, v2) < 0;
            };
          max_length: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v, length) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              return tosca.getLength(v) <= length;
            };
          min_length: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v, length) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              return tosca.getLength(v) >= length;
            };
          pattern: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            exports.validate = function(v, re) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              if (v.$string !== undefined)
                v = v.$string;
              return new RegExp('^' + re + '$').test(v);
            };
          schema: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3

            exports.validate = function() {
              // TODO
              return true;
            };
          valid_values: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v) {
              let values = Array.prototype.slice.call(arguments, 1);
              for (let i = 0, l = values.length; i < l; i++)
                if (tosca.deepEqual(values[i], v))
                  return true;
              return false;
            };
        function:
          _get_target_name: |-
            const tosca = require('tosca.lib.utils');

            exports.evaluate = function() {
              if (!this || !this.target)
                throw 'TARGET cannot be used in this context';
              if (!tosca.isNodeTemplate(this.target))
                throw 'TARGET is not a node template';
              return this.target.properties.name;
            };
          concat: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.3.1
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.3.1
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.3.1
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.3.1

            exports.evaluate = function() {
              let a = [];
              let length = arguments.length;
              for (let i = 0; i < length; i++) {
                let argument = arguments[i];
                if (argument.$string !== undefined)
                  argument = argument.$string;
                a.push(argument);
              }
              return a.join('');
            };
          get_artifact: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.8.1
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.8.1
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.8.1
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.8.1

            const tosca = require('tosca.lib.utils');

            exports.evaluate = function(entity, artifactName, location, remove) {
              if (arguments.length < 2)
                throw 'must have at least 2 arguments';
              let nodeTemplate = tosca.getModelableEntity.call(this, entity).properties;
              if (!nodeTemplate.artifacts || !(artifactName in nodeTemplate.artifacts))
                throw puccini.sprintf('artifact %q not found in %q', artifactName, nodeTemplate.name);
              let artifact = nodeTemplate.artifacts[artifactName];
              if (artifact.$artifact === undefined)
                return artifact.sourcePath;
              return artifact.$artifact;
            };
          get_attribute: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.5.1
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.5.1
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.5.1
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.5.1

            const tosca = require('tosca.lib.utils');

            exports.evaluate = function(entity, first) {
              return tosca.getNestedValue.call(this, 'attribute', 'attributes', arguments);
            };
          get_input: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.4.1
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.4.1
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.4.1
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.4.1

            const tosca = require('tosca.lib.utils');

            exports.evaluate = function(input) {
              if (arguments.length !== 1)
                throw 'must have 1 argument';
              if (!tosca.isTosca(clout))
                throw 'Clout is not TOSCA';
              let inputs = clout.properties.tosca.inputs;
              if (!(input in inputs))
                throw puccini.sprintf('input %q not found', input);
              let r = inputs[input];
              r = clout.coerce(r);
              return r;
            };
          get_nodes_of_type: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.7.1
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.7.1
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.7.1
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.7.1

            const tosca = require('tosca.lib.utils');

            exports.evaluate = function(typeName) {
              if (arguments.length !== 1)
                throw 'must have 1 argument';
              let names = [];
              for (let id in clout.vertexes) {
                let vertex = clout.vertexes[id];
                if (tosca.isTosca(vertex))
                  names.push(vertex.properties.name);
              }
              return names;
            };
          get_operation_output: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.6.1
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.6.1
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.6.1
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.6.1

            exports.evaluate = function() {
              return 'TODO';
            };
          get_property: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.4.2
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.4.2
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.4.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.4.2

            const tosca = require('tosca.lib.utils');

            exports.evaluate = function() {
              return tosca.getNestedValue.call(this, 'property', 'properties', arguments);
            };
          join: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.3.2

            exports.evaluate = function() {
              let length = arguments.length;
              if ((length < 1) || (length > 2))
                throw 'must have 1 or 2 arguments';
              let delimiter = (length == 2) ? arguments[1] : '';
              let args = arguments[0];
              length = args.length;
              let a = [];
              for (let i = 0; i < length; i++) {
                let argument = args[i];
                if (argument.$string !== undefined)
                  argument = argument.$string;
                a.push(argument);
              }
              return a.join(delimiter);
            };
          token: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.3.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.3.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.3.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.3.2

            exports.evaluate = function(v, separators, index) {
              if (arguments.length !== 3)
                throw 'must have 3 arguments';
              if (v.$string !== undefined)
                v = v.$string;
              let s = v.split(new RegExp('[' + escape(separators) + ']'));
              return s[index];
            };

            function escape(s) {
              return s.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
            }
        lib:
          traversal: |-
            const tosca = require('tosca.lib.utils');

            exports.toCoercibles = function(clout_) {
              if (!clout_)
                clout_ = clout;
              exports.traverseValues(clout_, function(data) {
                return clout_.newCoercible(data.value, data.site, data.source, data.target);
              });
            };

            exports.unwrapCoercibles = function(clout_) {
              if (!clout_)
                clout_ = clout;
              exports.traverseValues(clout_, function(data) {
                return clout_.unwrap(data.value);
              });
            };

            exports.coerce = function(clout_) {
              if (!clout_)
                clout_ = clout;
              exports.toCoercibles(clout_);
              exports.traverseValues(clout_, function(data) {
                return clout_.coerce(data.value);
              });
            };

            exports.getValueType = function(clout_) {
              if (!clout_)
                clout_ = clout;
              let valueType = {};
              exports.traverseValues(clout_, function(data) {
                if (data.value.$meta)
                  valueType[data.path.join('.')] = data.value.$meta.type;
                return data.value;
              });
              return valueType;
            };

            exports.hasQuirk = function(clout_, quirk) {
              if (!clout_)
                clout_ = clout;
              let quirks = clout_.properties.tosca.metadata['puccini.quirks'];
              if (quirks !== undefined) {
                quirks = quirks.split(',');
                for (let q = 0, l = quirks.length; q < l; q++)
                  if (quirks[q] === quirk)
                    return true;
              }
              return false;
            };

            exports.traverseValues = function(clout_, traverser) {
              if (!clout_)
                clout_ = clout;

              if (tosca.isTosca(clout_)) {
                exports.traverseObjectValues(traverser, ['inputs'], clout_.properties.tosca.inputs);
                exports.traverseObjectValues(traverser, ['outputs'], clout_.properties.tosca.outputs);
              }

              for (let vertexId in clout_.vertexes) {
                let vertex = clout_.vertexes[vertexId];
                if (!tosca.isTosca(vertex))
                  continue;

                if (tosca.isNodeTemplate(vertex)) {
                  let nodeTemplate = vertex.properties;
                  let path = ['nodeTemplates', nodeTemplate.name];

                  exports.traverseObjectValues(traverser, copyAndPush(path, 'properties'), nodeTemplate.properties, vertex);
                  exports.traverseObjectValues(traverser, copyAndPush(path, 'attributes'), nodeTemplate.attributes, vertex);
                  exports.traverseInterfaceValues(traverser, copyAndPush(path, 'interfaces'), nodeTemplate.interfaces, vertex)

                  for (let capabilityName in nodeTemplate.capabilities) {
                    let capability = nodeTemplate.capabilities[capabilityName];
                    let capabilityPath = copyAndPush(path, 'capabilities', capabilityName);
                    exports.traverseObjectValues(traverser, copyAndPush(capabilityPath, 'properties'), capability.properties, vertex);
                    exports.traverseObjectValues(traverser, copyAndPush(capabilityPath, 'attributes'), capability.attributes, vertex);
                  }

                  for (let artifactName in nodeTemplate.artifacts) {
                    let artifact = nodeTemplate.artifacts[artifactName];
                    let artifactPath = copyAndPush(path, 'artifacts', artifactName);
                    exports.traverseObjectValues(traverser, copyAndPush(artifactPath, 'properties'), artifact.properties, vertex);
                    if (artifact.credential !== null)
                      try {
                        artifact.credential = traverser({
                          path: copyAndPush(artifactPath, 'credential'),
                          value: artifact.credential,
                          site: vertex
                        });
                      } catch (x) {
                        if ((typeof problems !== 'undefined') && x.value && x.value.error)
                          // Unwrap Go error
                          problems.reportError(x.value);
                        else
                          throw x;
                      }
                  }

                  for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {
                    let edge = vertex.edgesOut[e];
                    if (!tosca.isTosca(edge, 'Relationship'))
                      continue;

                    let relationship = edge.properties;
                    let relationshipPath = copyAndPush(path, 'relationships', relationship.name);
                    exports.traverseObjectValues(traverser, copyAndPush(relationshipPath, 'properties'), relationship.properties, edge, vertex, edge.target);
                    exports.traverseObjectValues(traverser,copyAndPush(relationshipPath, 'attributes'), relationship.attributes, edge, vertex, edge.target);
                    exports.traverseInterfaceValues(traverser, copyAndPush(relationshipPath, 'interfaces'), relationship.interfaces, edge, vertex, edge.target);
                  }
                } else if (tosca.isTosca(vertex, 'Group')) {
                  let group = vertex.properties;
                  let path = ['groups', group.name];

                  exports.traverseObjectValues(traverser, copyAndPush(path, 'properties'), group.properties, vertex);
                  exports.traverseInterfaceValues(traverser, copyAndPush(path, 'attributes'), group.interfaces, vertex)
                } else if (tosca.isTosca(vertex, 'Policy')) {
                  let policy = vertex.properties;
                  let path = ['policies', policy.name];

                  exports.traverseObjectValues(traverser, copyAndPush(path, 'properties'), policy.properties, vertex);
                } else if (tosca.isTosca(vertex, 'Substitution')) {
                  let substitution = vertex.properties;
                  let path = ['substitution'];

                  exports.traverseObjectValues(traverser, copyAndPush(path, 'properties'), substitution.properties, vertex);
                }
              }
            };

            exports.traverseInterfaceValues = function(traverser, path, interfaces, site, source, target) {
              for (let interfaceName in interfaces) {
                let interface_ = interfaces[interfaceName];
                let interfacePath = copyAndPush(path, interfaceName)
                exports.traverseObjectValues(traverser, copyAndPush(interfacePath, 'inputs'), interface_.inputs, site, source, target);
                for (let operationName in interface_.operations) {
                  let operationPath = copyAndPush(interfacePath, 'operations', operationName);
                  exports.traverseObjectValues(traverser, operationPath, interface_.operations[operationName].inputs, site, source, target);
                  exports.traverseObjectValues(traverser, operationPath, interface_.operations[operationName].outputs, site, source, target);
                }
                for (let notificationName in interface_.notifications) {
                  let notificationPath = copyAndPush(interfacePath, 'notifications', notificationName);
                  exports.traverseObjectValues(traverser, notificationPath, interface_.notifications[notificationName].outputs, site, source, target);
                }
              }
            };

            exports.traverseObjectValues = function(traverser, path, object, site, source, target) {
              for (let key in object)
                try {
                  object[key] = traverser({
                    path: copyAndPush(path, key),
                    value: object[key],
                    site: site,
                    source: source,
                    target: target
                  });
                } catch (x) {
                  if ((typeof problems !== 'undefined') && x.value && x.value.error)
                    // Unwrap Go error
                    problems.reportError(x.value);
                  else
                    throw x;
                }
            };

            function copyAndPush(array) {
              let array_ = [];
              for (let i = 0, l = array.length; i < l; i++)
                array_.push(array[i]);
              for (let i = 1, l = arguments.length; i < l; i++)
                array_.push(arguments[i]);
              return array_;
            }
          utils: |-
            exports.isTosca = function(o, kind) {
              if (o.metadata === undefined)
                return false;
              o = o.metadata['puccini'];
              if (o === undefined)
                return false;
              if (o.version !== '1.0')
                return false;
              if (kind !== undefined)
                return kind === o.kind;
              return true;
            };

            exports.isNodeTemplate = function(vertex, typeName) {
              if (exports.isTosca(vertex, 'NodeTemplate')) {
                if (typeName !== undefined)
                  return typeName in vertex.properties.types;
                return true;
              }
              return false;
            };

            exports.setOutputValue = function(name, value) {
              if (clout.properties.tosca === undefined)
                return false;
              let output = clout.properties.tosca.outputs[name];
              if (output === undefined)
                return false;

              if (output.$type && output.$type.type)
                switch (output.$type.type.name) {
                case 'boolean':
                  value = (value === 'true');
                  break;
                case 'integer':
                  value = parseInt(value);
                  break;
                case 'float':
                  value = parseFloat(value);
                  break;
                }

              output.$value = value;
              return true;
            };

            exports.getPolicyTargets = function(vertex) {
              let targets = [];

              function addTarget(target) {
                for (let t = 0, l = targets.length; t < l; t++)
                  if (targets[t].name === target.name)
                    return;
                targets.push(target);
              }

              for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {
                let edge = vertex.edgesOut[e];
                if (exports.isTosca(edge, 'NodeTemplateTarget'))
                  targets.push(clout.vertexes[edge.targetID].properties);
                else if (toexportssca.isTosca(edge, 'GroupTarget')) {
                  let members = exports.getGroupMembers(clout.vertexes[edge.targetID]);
                  for (let m = 0, ll = members.length; m < ll; m++)
                    addTarget(members[m])
                }
              }
              return targets;
            };

            exports.getGroupMembers = function(vertex) {
              let members = [];
              for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {
                let edge = vertex.edgesOut[e];
                if (exports.isTosca(edge, 'Member'))
                  members.push(clout.vertexes[edge.targetID].properties);
              }
              return members;
            };

            exports.addHistory = function(description) {
              let metadata = clout.metadata;
              if (metadata === undefined)
                metadata = clout.metadata = {};
              let history = metadata.history;
              if (history === undefined)
                history = [];
              else
                history = history.slice(0);
              history.push({
                timestamp: puccini.nowString(),
                description: description
              });
              metadata.history = history;
            };

            exports.getNestedValue = function(singular, plural, args) {
              args = Array.prototype.slice.call(args);
              let length = args.length;
              if (length < 2)
                throw 'must have at least 2 arguments';
              let vertex = exports.getModelableEntity.call(this, args[0]);
              let nodeTemplate = vertex.properties;
              let value = nodeTemplate[plural];
              let a = 1;
              let arg = args[a];
              let nextArg = args[a+1];
              let count = 0;
              if (arg in nodeTemplate.capabilities) {
                value = nodeTemplate.capabilities[arg][plural];
                singular = puccini.sprintf('capability %q %s', arg, singular);
                arg = args[++a];
              } else for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {
                let edge = vertex.edgesOut[e];
                if (!exports.isTosca(edge, 'Relationship'))
                  continue;
                let relationship = edge.properties;
                if (relationship.name === arg)
                  if (count++ === nextArg) {
                    value = relationship[plural];
                    singular = puccini.sprintf('relationship %q %s', arg, singular);
                    a += 2;
                    arg = args[a];
                    break;
                  }
              }
              if ((typeof value === 'object') && (value !== null) && (arg in value))
                value = value[arg];
              else
                throw puccini.sprintf('%s %q not found in %q', singular, arg, nodeTemplate.name);
              value = clout.coerce(value);
              for (let i = a + 1; i < length; i++) {
                arg = args[i];
                if ((typeof value === 'object') && (value !== null) && (arg in value))
                  value = value[arg];
                else
                  throw puccini.sprintf('nested %s %q not found in %q', singular, args.slice(a, i+1).join('.'), nodeTemplate.name);
              }
              return value;
            };

            exports.getModelableEntity = function(entity) {
              let vertex;
              switch (entity) {
              case 'SELF':
                if (!this || !this.site)
                  throw puccini.sprintf('%q cannot be used in this context', entity);
                vertex = this.site;
                break;
              case 'SOURCE':
                if (!this || !this.source)
                  throw puccini.sprintf('%q cannot be used in this context', entity);
                vertex = this.source;
                break;
              case 'TARGET':
                if (!this || !this.target)
                  throw puccini.sprintf('%q cannot be used in this context', entity);
                vertex = this.target;
                break;
              case 'HOST':
                if (!this || !this.site)
                  throw puccini.sprintf('%q cannot be used in this context', entity);
                vertex = exports.getHost(this.site);
                break;
              default:
                for (let vertexId in clout.vertexes) {
                  let vertex = clout.vertexes[vertexId];
                  if (exports.isNodeTemplate(vertex) && (vertex.properties.name === entity))
                    return vertex;
                }
                vertex = {};
              }
              if (exports.isNodeTemplate(vertex))
                return vertex;
              else
                throw puccini.sprintf('%q node template not found', entity);
            };

            exports.getHost = function(vertex) {
              for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {
                let edge = vertex.edgesOut[e];
                if (exports.isTosca(edge, 'Relationship')) {
                  for (let typeName in edge.properties.types) {
                    let type = edge.properties.types[typeName];
                    if (type.metadata.role === 'host')
                      return edge.target;
                  }
                }
              }
              if (exports.isNodeTemplate(vertex))
                throw puccini.sprintf('"HOST" not found for node template %q', vertex.properties.name);
              else
                throw '"HOST" not found';
            };

            exports.getComparable = function(v) {
              if ((v === undefined) || (v === null))
                return null;
              let c = v.$number;
              if (c !== undefined)
                return c;
              c = v.$string;
              if (c !== undefined)
                return c;
              return v;
            };

            exports.getLength = function(v) {
              if (v.$string !== undefined)
                v = v.$string;
              let length = v.length;
              if (length === undefined)
                length = Object.keys(v).length;
              return length;
            };

            exports.compare = function(v1, v2) {
              let c = v1.$comparer;
              if (c === undefined)
                c = v2.$comparer;
              if (c !== undefined)
                return clout.call(c, 'compare', [v1, v2]);
              v1 = exports.getComparable(v1);
              v2 = exports.getComparable(v2);
              if (v1 == v2)
                return 0;
              else if (v1 < v2)
                return -1;
              else
                return 1;
            };

            // See: https://stackoverflow.com/a/45683145
            exports.deepEqual = function(v1, v2) {
              if (v1 === v2)
                return true;

              if (exports.isPrimitive(v1) && exports.isPrimitive(v2))
                return v1 === v2;

              if (Object.keys(v1).length !== Object.keys(v2).length)
                return false;

              for (let key in v1) {
                if (!(key in v2)) return false;
                if (!exports.deepEqual(v1[key], v2[key])) return false;
              }

              return true;
            };

            exports.isPrimitive = function(obj) {
              return obj !== Object(obj);
            };
        outputs: |-
          const traversal = require('tosca.lib.traversal');
          const tosca = require('tosca.lib.utils');

          traversal.coerce();

          if (tosca.isTosca(clout))
              puccini.write(clout.properties.tosca.outputs);
        resolve: |-
          const traversal = require('tosca.lib.traversal');
          const tosca = require('tosca.lib.utils');

          const enforceCapabilityOccurrences = !traversal.hasQuirk(clout, 'capabilities.occurrences.permissive');

          // Remove existing relationships
          let nodeTemplateVertexes = [];
          for (let vertexId in clout.vertexes) {
            let vertex = clout.vertexes[vertexId];
            if (tosca.isNodeTemplate(vertex)) {
              nodeTemplateVertexes.push(vertex);
              let remove = [];
              for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {
                let edge = vertex.edgesOut[e];
                if (tosca.isTosca(edge, 'Relationship'))
                  remove.push(edge);
              }
              for (let e = 0, l = remove.length; e < l; e++)
                remove[e].remove();
            }
          }

          // For consistent results, we will sort the node templates by name
          nodeTemplateVertexes.sort(function(a, b) {
            return a.properties.name < b.properties.name ? -1 : 1;
          });

          traversal.toCoercibles();

          // Resolve all requirements
          for (let v = 0, l = nodeTemplateVertexes.length; v < l; v++) {
            let vertex = nodeTemplateVertexes[v];
            let nodeTemplate = vertex.properties;
            let requirements = nodeTemplate.requirements;
            for (let r = 0, ll = requirements.length; r < ll; r++) {
              let requirement = requirements[r];
              resolve(vertex, nodeTemplate, requirement);
            }
          }

          if (enforceCapabilityOccurrences)
            for (let v = 0, l = nodeTemplateVertexes.length; v < l; v++) {
              let vertex = nodeTemplateVertexes[v];
              let nodeTemplate = vertex.properties;
              let capabilities = nodeTemplate.capabilities;
              for (let capabilityName in capabilities) {
                let capability = capabilities[capabilityName];
                let relationshipCount = countRelationships(vertex, capabilityName);
                let minRelationshipCount = capability.minRelationshipCount;
                if (relationshipCount < minRelationshipCount)
                  notEnoughRelationships(capability.location, relationshipCount, minRelationshipCount)
              }
            }

          traversal.unwrapCoercibles();

          if (puccini.arguments.history !== 'false')
            tosca.addHistory('resolve');
          puccini.write(clout)

          function resolve(sourceVertex, sourceNodeTemplate, requirement) {
            let location = requirement.location;
            let name = requirement.name;

            if (isSubstituted(sourceNodeTemplate.name, name)) {
              puccini.log.debugf('%s: skipping because in substitution mappings', location.path)
              return;
            }

            let candidates = gatherCandidateNodeTemplates(sourceVertex, requirement);
            if (candidates.length === 0) {
              unsatisfied(location, name, 'there are no candidate node templates');
              return;
            }

            candidates = gatherCandidateCapabilities(requirement, candidates);
            if (candidates.length === 0) {
              unsatisfied(location, name, 'no candidate node template provides required capability');
              return;
            }

            // Gather priority candidates: those that have not yet fulfilled their minimum relationship count
            let priorityCandidates = [];
            for (let c = 0, l = candidates.length; c < l; c++) {
              let candidate = candidates[c];
              if ((candidate.capability.minRelationshipCount !== 0) && (countRelationships(candidate.vertex, candidate.capabilityName) < candidate.capability.minRelationshipCount))
                priorityCandidates.push(candidate);
            }

            let chosen = null;

            if (priorityCandidates.length !== 0)
              // Of the priority candidates, pick the one with the highest minimum relationship count
              // (needs to be fulfilled soonest)
              for (let c = 0, l = priorityCandidates.length; c < l; c++) {
                let candidate = priorityCandidates[c];
                if ((chosen === null) || (candidate.capability.minRelationshipCount > chosen.capability.minRelationshipCount))
                  chosen = candidate;
              }
            else
              // Of the candidates, pick the one with highest maximum relationship count
              // (has the most room)
              for (let c = 0, l = candidates.length; c < l; c++) {
                let candidate = candidates[c];
                if ((chosen === null) || isMaxCountGreater(candidate.capability.maxRelationshipCount, chosen.capability.maxRelationshipCount))
                  chosen = candidate;
              }

            puccini.log.debugf('%s: satisfied %q with capability %q in node template %q', location.path, name, chosen.capabilityName, chosen.nodeTemplateName);
            addRelationship(sourceVertex, requirement, chosen.vertex, chosen.capabilityName);
          }

          function gatherCandidateNodeTemplates(sourceVertex, requirement) {
            let path = requirement.location.path;
            let nodeTemplateName = requirement.nodeTemplateName;
            let nodeTypeName = requirement.nodeTypeName;
            let nodeTemplatePropertyValidators = requirement.nodeTemplatePropertyValidators;
            let capabilityPropertyValidatorsMap = requirement.capabilityPropertyValidators;

            let candidates = [];
            for (let v = 0, l = nodeTemplateVertexes.length; v < l; v++) {
              let vertex = nodeTemplateVertexes[v];
              let candidateNodeTemplate = vertex.properties;
              let candidateNodeTemplateName = candidateNodeTemplate.name;

              if ((nodeTemplateName !== '') && (nodeTemplateName !== candidateNodeTemplateName)) {
                puccini.log.debugf('%s: node template %q is not named %q', path, candidateNodeTemplateName, nodeTemplateName);
                continue;
              }

              if ((nodeTypeName !== '') && !(nodeTypeName in candidateNodeTemplate.types)) {
                puccini.log.debugf('%s: node template %q is not of type %q', path, candidateNodeTemplateName, nodeTypeName);
                continue;
              }

              // Node filter
              if ((nodeTemplatePropertyValidators.length !== 0) && !arePropertiesValid(path, sourceVertex, 'node template', candidateNodeTemplateName, candidateNodeTemplate, nodeTemplatePropertyValidators)) {
                puccini.log.debugf('%s: properties of node template %q do not validate', path, candidateNodeTemplateName);
                continue;
              }

              let candidateCapabilities = candidateNodeTemplate.capabilities;

              // Capability filter
              if (capabilityPropertyValidatorsMap.length !== 0) {
                let valid = true;
                for (let candidateCapabilityName in candidateCapabilities) {
                  let candidateCapability = candidateCapabilities[candidateCapabilityName];

                  // Try by name
                  let capabilityPropertyValidators = capabilityPropertyValidatorsMap[candidateCapabilityName];
                  if (capabilityPropertyValidators === undefined) {
                    // Try by type name
                    for (let candidateTypeName in candidateCapability.types) {
                      capabilityPropertyValidators = capabilityPropertyValidatorsMap[candidateTypeName];
                      if (capabilityPropertyValidators !== undefined) break;
                    }
                  }

                  if ((capabilityPropertyValidators !== undefined) && (capabilityPropertyValidators.length !== 0) && !arePropertiesValid(path, sourceVertex, 'capability', candidateCapabilityName, candidateCapability, capabilityPropertyValidators)) {
                    puccini.log.debugf('%s: properties of capability %q in node template %q do not validate', path, candidateCapabilityName, candidateNodeTemplateName);
                    valid = false;
                    break;
                  }
                }
                if (!valid)
                  continue;
              }

              candidates.push({
                vertex: vertex,
                nodeTemplateName: candidateNodeTemplateName,
                capabilities: candidateCapabilities
              });
            }

            return candidates;
          }

          function gatherCandidateCapabilities(requirement, candidateNodeTemplates) {
            let path = requirement.location.path;
            let capabilityName = requirement.capabilityName;
            let capabilityTypeName = requirement.capabilityTypeName;

            let candidates = [];
            for (let c = 0, l = candidateNodeTemplates.length; c < l; c++) {
              let candidate = candidateNodeTemplates[c];
              let candidateVertex = candidate.vertex;
              let candidateNodeTemplateName = candidate.nodeTemplateName;

              let candidateCapabilities = [];
              for (let candidateCapabilityName in candidate.capabilities) {
                candidateCapabilities.push({
                  name: candidateCapabilityName,
                  capability: candidate.capabilities[candidateCapabilityName]
                });
              }

              // For consistent results, we will sort the candidate capabilities by name
              candidateCapabilities.sort(function(a, b) {
                return a.name < b.name ? -1 : 1;
              });

              for (let cc = 0, ll = candidateCapabilities.length; cc < ll; cc++) {
                let candidateCapabilityName = candidateCapabilities[cc].name;

                if ((capabilityName !== '') && (capabilityName !== candidateCapabilityName)) {
                  puccini.log.debugf('%s: capability %q in node template %q is not named %q', path, candidateCapabilityName, candidateNodeTemplateName, capabilityName);
                  continue;
                }

                let candidateCapability = candidateCapabilities[cc].capability;

                if ((capabilityTypeName !== '') && !(capabilityTypeName in candidateCapability.types)) {
                  puccini.log.debugf('%s: capability %q in node template %q is not of type %q', path, candidateCapabilityName, candidateNodeTemplateName, capabilityTypeName);
                  continue;
                }

                if (enforceCapabilityOccurrences) {
                  let maxRelationshipCount = candidateCapability.maxRelationshipCount;
                  if ((maxRelationshipCount !== -1) && (countRelationships(candidateVertex, candidateCapabilityName) === maxRelationshipCount)) {
                    puccini.log.debugf('%s: capability %q in node template %q already has %d relationships, the maximum allowed', path, candidateCapabilityName, candidateNodeTemplateName, maxRelationshipCount);
                    continue;
                  }
                }

                candidates.push({
                  vertex: candidateVertex,
                  nodeTemplateName: candidateNodeTemplateName,
                  capability: candidateCapability,
                  capabilityName: candidateCapabilityName
                });
              }
            }

            return candidates;
          }

          function addRelationship(sourceVertex, requirement, targetVertex, capabilityName) {
            let edge = sourceVertex.newEdgeTo(targetVertex);
            edge.metadata['puccini'] = {
              version: '1.0',
              kind: 'Relationship'
            };

            let relationship = requirement.relationship;
            if (relationship)
              edge.properties = {
                name: requirement.name,
                description: relationship.description,
                types: relationship.types,
                properties: relationship.properties,
                attributes: relationship.attributes,
                interfaces: relationship.interfaces,
                capability: capabilityName
              };
            else
              // Untyped relationship
              edge.properties = {
                name: requirement.name,
                description: '',
                types: {},
                properties: {},
                attributes: {},
                interfaces: {},
                capability: capabilityName
              };
          }

          function countRelationships(vertex, capabilityName) {
            let count = 0;
            for (let e = 0, l = vertex.edgesIn.size(); e < l; e++) {
              let edge = vertex.edgesIn[e];
              if (tosca.isTosca(edge, 'Relationship') && (edge.properties.capability === capabilityName))
                count++;
            }
            return count;
          }

          function arePropertiesValid(path, sourceVertex, kind, name, entity, validatorsMap) {
            let valid = true;

            let properties = entity.properties;
            for (let propertyName in validatorsMap) {
              puccini.log.debugf('%s: applying validators to property %q of %s %q', path, propertyName, kind, name);

              let property = properties[propertyName];
              if (property === undefined) {
                // return false; GOJA: returning from inside for-loop is broken
                valid = false;
                break;
              }

              let validators = validatorsMap[propertyName];
              validators = clout.newValidators(validators, sourceVertex, sourceVertex, entity)
              if (!validators.isValid(property)) {
                // return false; GOJA: returning from inside for-loop is broken
                valid = false;
                break;
              }
            }

            return valid;
          }

          function isSubstituted(nodeTemplateName, requirementName) {
            for (let vertexId in clout.vertexes) {
              let vertex = clout.vertexes[vertexId];
              if (tosca.isTosca(vertex, 'Substitution')) {
                for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {
                  let edge = vertex.edgesOut[e];
                  if (!tosca.isTosca(edge, 'RequirementPointer'))
                    continue;

                  if ((edge.target.properties.name === nodeTemplateName) && (edge.properties.target === requirementName))
                    return true;
                }

                // There's only ever one substitution
                return false;
              }
            }

            return false;
          }

          function isMaxCountGreater(a, b) {
            if (a == -1)
              return b !== -1;
            else if (b == -1)
              return false;
            return a > b;
          }

          function unsatisfied(location, name, message) {
            if (typeof problems === 'undefined')
              throw puccini.sprintf('%s: could not satisfy %q because %s', location.path, name, message);
            else
              problems.reportFull(11, 'Resolution', location.path, puccini.sprintf('could not satisfy %q because %s', name, message), location.row, location.column);
          }

          function notEnoughRelationships(location, relationshipCount, minRelationshipCount) {
            if (typeof problems === 'undefined')
              throw puccini.sprintf('%s: not enough relationships: %d < %d', location.path, relationshipCount, minRelationshipCount);
            else
              problems.reportFull(11, 'Resolution', location.path, puccini.sprintf('not enough relationships: %d < %d', relationshipCount, minRelationshipCount), location.row, location.column);
          }
    version: "1.0"
properties:
  tosca:
    description: ""
    inputs: {}
    metadata:
      template_author: shishqa
      template_name: nginx-ansible
      template_version: "1.0"
    outputs: {}
vertexes:
  _2N5YqNkY1i3QUcj6qcIaVFumD3p:
    metadata:
      puccini:
        kind: Substitution
        version: "1.0"
    properties:
      inputs: {}
      properties: {}
      type: Nginx
      typeMetadata: {}
    edgesOut:
      - metadata:
          puccini:
            kind: CapabilityPointer
            version: "1.0"
        properties:
          name: host
          target: host
        targetID: _2N5YqOl8QYwbwSRi8ACfrYlQ1Cl
      - metadata:
          puccini:
            kind: CapabilityPointer
            version: "1.0"
        properties:
          name: data_endpoint
          target: data_endpoint
        targetID: _2N5YqOl8QYwbwSRi8ACfrYlQ1Cl
      - metadata:
          puccini:
            kind: CapabilityPointer
            version: "1.0"
        properties:
          name: admin_endpoint
          target: admin_endpoint
        targetID: _2N5YqOl8QYwbwSRi8ACfrYlQ1Cl
  _2N5YqOl8QYwbwSRi8ACfrYlQ1Cl:
    metadata:
      puccini:
        kind: NodeTemplate
        version: "1.0"
    properties:
      artifacts: {}
      attributes:
        state:
          $meta:
            description: The state of the node instance.
            type: string
          $primitive: initial
        tosca_id:
          $meta:
            description: A unique identifier of the realized instance of a Node Template that derives from any TOSCA normative type.
            type: string
          $primitive: null
        tosca_name:
          $meta:
            description: This attribute reflects the name of the Node Template as defined in the TOSCA service template. This name is not unique to the realized instance model of corresponding deployed application as each template in the model can result in one or more instances (e.g., scaled) when orchestrated to a provider environment.
            type: string
          $primitive: null
      capabilities:
        admin_endpoint:
          attributes:
            ip_address:
              $meta:
                description: 'Note: This is the IP address as propagated up by the associated node''s host (Compute) container.'
                type: string
              $primitive: null
          description: ""
          location:
            column: 7
            path: topology_template.node_templates["nginx"].capabilities["admin_endpoint"]
            row: 21
          maxRelationshipCount: -1
          minRelationshipCount: 0
          properties:
            initiator:
              $meta:
                description: The optional indicator of the direction of the connection.
                type: string
                validators:
                  - $functionCall:
                      arguments:
                        - $primitive: source
                        - $primitive: target
                        - $primitive: peer
                      column: 9
                      name: tosca.constraint.valid_values
                      path: capability_types["tosca.capabilities.Endpoint"].properties["initiator"].default
                      row: 170
                      url: internal:/tosca/simple/1.3/capabilities.yaml
              $primitive: source
            network_name:
              $meta:
                description: 'The optional name (or ID) of the network this endpoint should be bound to. network_name: PRIVATE | PUBLIC | <network_name> | <network_id>.'
                type: string
              $primitive: PRIVATE
            protocol:
              $meta:
                description: 'The name of the protocol (i.e., the protocol prefix) that the endpoint accepts (any OSI Layer 4-7 protocols). Examples: http, https, ftp, tcp, udp, etc.'
                type: string
              $primitive: tcp
            secure:
              $meta:
                description: Requests for the endpoint to be secure and use credentials supplied on the ConnectsTo relationship.
                type: boolean
                validators:
                  - $functionCall:
                      arguments:
                        - $primitive: true
                      column: 9
                      name: tosca.constraint.equal
                      path: capability_types["tosca.capabilities.Endpoint.Admin"].properties["secure"].default
                      row: 239
                      url: internal:/tosca/simple/1.3/capabilities.yaml
              $primitive: true
          types:
            tosca::Endpoint:
              description: This is the default TOSCA type that should be used or extended to define a network endpoint capability. This includes the information to express a basic endpoint with a single port or a complex endpoint with multiple ports. By default the Endpoint is assumed to represent an address on a private network unless otherwise specified.
              metadata:
                specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
                specification.location: 5.5.7
                tosca.canonical-name: tosca::Endpoint
                tosca.normative: "true"
              parent: tosca::Root
            tosca::Endpoint.Admin:
              description: This is the default TOSCA type that should be used or extended to define a specialized administrator endpoint capability.
              metadata:
                specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
                specification.location: 5.5.9
                tosca.canonical-name: tosca::Endpoint.Admin
                tosca.normative: "true"
              parent: tosca::Endpoint
            tosca::Root:
              description: This is the default (root) TOSCA Capability Type definition that all other TOSCA Capability Types derive from.
              metadata:
                specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
                specification.location: 5.5.1
                tosca.canonical-name: tosca::Root
                tosca.normative: "true"
        data_endpoint:
          attributes:
            ip_address:
              $functionCall:
                arguments:
                  - $primitive: SELF
                  - $primitive: host
                  - $primitive: public_address
                column: 13
                name: tosca.function.get_attribute
                path: topology_template.node_templates["nginx"].capabilities["data_endpoint"].attributes["ip_address"]
                row: 24
                url: file:/home/shishqa/dev/ispras/tosca-mock/tosca/templates/nginx/nginx.yaml
              $meta:
                description: 'Note: This is the IP address as propagated up by the associated node''s host (Compute) container.'
                type: string
          description: ""
          location:
            column: 9
            path: topology_template.node_templates["nginx"].capabilities["data_endpoint"]
            row: 22
          maxRelationshipCount: -1
          minRelationshipCount: 0
          properties:
            initiator:
              $meta:
                description: The optional indicator of the direction of the connection.
                type: string
                validators:
                  - $functionCall:
                      arguments:
                        - $primitive: source
                        - $primitive: target
                        - $primitive: peer
                      column: 9
                      name: tosca.constraint.valid_values
                      path: capability_types["tosca.capabilities.Endpoint"].properties["initiator"].default
                      row: 170
                      url: internal:/tosca/simple/1.3/capabilities.yaml
              $primitive: source
            network_name:
              $meta:
                description: 'The optional name (or ID) of the network this endpoint should be bound to. network_name: PRIVATE | PUBLIC | <network_name> | <network_id>.'
                type: string
              $primitive: PRIVATE
            protocol:
              $meta:
                description: 'The name of the protocol (i.e., the protocol prefix) that the endpoint accepts (any OSI Layer 4-7 protocols). Examples: http, https, ftp, tcp, udp, etc.'
                type: string
              $primitive: tcp
            secure:
              $meta:
                description: Requests for the endpoint to be secure and use credentials supplied on the ConnectsTo relationship.
                type: boolean
              $primitive: false
          types:
            tosca::Endpoint:
              description: This is the default TOSCA type that should be used or extended to define a network endpoint capability. This includes the information to express a basic endpoint with a single port or a complex endpoint with multiple ports. By default the Endpoint is assumed to represent an address on a private network unless otherwise specified.
              metadata:
                specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
                specification.location: 5.5.7
                tosca.canonical-name: tosca::Endpoint
                tosca.normative: "true"
              parent: tosca::Root
            tosca::Root:
              description: This is the default (root) TOSCA Capability Type definition that all other TOSCA Capability Types derive from.
              metadata:
                specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
                specification.location: 5.5.1
                tosca.canonical-name: tosca::Root
                tosca.normative: "true"
        feature:
          attributes: {}
          description: ""
          location:
            column: 7
            path: topology_template.node_templates["nginx"].capabilities["feature"]
            row: 21
          maxRelationshipCount: -1
          minRelationshipCount: 0
          properties: {}
          types:
            tosca::Node:
              description: The Node capability indicates the base capabilities of a TOSCA Node Type.
              metadata:
                specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
                specification.location: 5.5.2
                tosca.canonical-name: tosca::Node
                tosca.normative: "true"
              parent: tosca::Root
            tosca::Root:
              description: This is the default (root) TOSCA Capability Type definition that all other TOSCA Capability Types derive from.
              metadata:
                specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
                specification.location: 5.5.1
                tosca.canonical-name: tosca::Root
                tosca.normative: "true"
        host:
          attributes: {}
          description: ""
          location:
            column: 7
            path: topology_template.node_templates["nginx"].capabilities["host"]
            row: 21
          maxRelationshipCount: -1
          minRelationshipCount: 0
          properties: {}
          types:
            tosca::Compute:
              description: The Compute capability, when included on a Node Type or Template definition, indicates that the node can provide hosting on a named compute resource.
              metadata:
                role: host
                specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
                specification.location: 5.5.3
                tosca.canonical-name: tosca::Compute
                tosca.normative: "true"
              parent: tosca::Container
            tosca::Container:
              description: The Container capability, when included on a Node Type or Template definition, indicates that the node can act as a container for (or a host for) one or more other declared Node Types.
              metadata:
                specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
                specification.location: 5.5.6
                tosca.canonical-name: tosca::Container
                tosca.normative: "true"
              parent: tosca::Root
            tosca::Root:
              description: This is the default (root) TOSCA Capability Type definition that all other TOSCA Capability Types derive from.
              metadata:
                specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
                specification.location: 5.5.1
                tosca.canonical-name: tosca::Root
                tosca.normative: "true"
      description: ""
      directives: []
      interfaces:
        Standard:
          description: This lifecycle interface defines the essential, normative operations that TOSCA nodes may support.
          inputs: {}
          notifications: {}
          operations:
            configure:
              dependencies: []
              description: Standard lifecycle configure operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            create:
              dependencies: []
              description: Standard lifecycle create operation.
              host: HOST
              implementation: artifacts/nginx/ansible/create.yaml
              inputs: {}
              outputs: {}
              timeout: -1
            delete:
              dependencies: []
              description: Standard lifecycle delete operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            start:
              dependencies: []
              description: Standard lifecycle start operation.
              host: HOST
              implementation: artifacts/nginx/ansible/start.yaml
              inputs: {}
              outputs: {}
              timeout: -1
            stop:
              dependencies: []
              description: Standard lifecycle stop operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            tosca::Root:
              description: This is the default (root) TOSCA Interface Type definition that all other TOSCA Interface Types derive from.
              metadata:
                specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
                specification.location: 5.8.3
                tosca.canonical-name: tosca::Root
                tosca.normative: "true"
            tosca::Standard:
              description: This lifecycle interface defines the essential, normative operations that TOSCA nodes may support.
              metadata:
                specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
                specification.location: 5.8.4
                tosca.canonical-name: tosca::Standard
                tosca.normative: "true"
              parent: tosca::Root
      metadata: null
      name: nginx
      properties:
        component_version:
          $meta:
            description: The optional software component's version.
            type: version
          $primitive:
            $comparer: tosca.comparer.version
            $originalString: 1.2.3
            $string: 1.2.3
            build: 0
            fix: 3
            major: 1
            minor: 2
            qualifier: ""
      requirements:
        - capabilityName: ""
          capabilityPropertyValidators: {}
          capabilityTypeName: tosca::Compute
          directives: null
          location:
            column: 5
            path: topology_template.node_templates["nginx"].requirements{0}
            row: 17
          name: host
          nodeTemplateName: ""
          nodeTemplatePropertyValidators: {}
          nodeTypeName: tosca::Compute
          optional: false
          relationship:
            attributes:
              state:
                $meta:
                  description: The state of the relationship instance.
                  type: string
                $primitive: initial
              tosca_id:
                $meta:
                  description: A unique identifier of the realized instance of a Relationship Template that derives from any TOSCA normative type.
                  type: string
                $primitive: null
              tosca_name:
                $meta:
                  description: This attribute reflects the name of the Relationship Template as defined in the TOSCA service template. This name is not unique to the realized instance model of corresponding deployed application as each template in the model can result in one or more instances (e.g., scaled) when orchestrated to a provider environment.
                  type: string
                $primitive: null
            description: ""
            interfaces:
              Configure:
                description: The lifecycle interfaces define the essential, normative operations that each TOSCA Relationship Types may support.
                inputs: {}
                notifications: {}
                operations:
                  add_source:
                    dependencies: []
                    description: Operation to notify the target node of a source node which is now available via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  add_target:
                    dependencies: []
                    description: Operation to notify the source node of a target node being added via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_source:
                    dependencies: []
                    description: Operation to post-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_target:
                    dependencies: []
                    description: Operation to post-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_source:
                    dependencies: []
                    description: Operation to pre-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_target:
                    dependencies: []
                    description: Operation to pre-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  remove_source:
                    dependencies: []
                    description: Operation to remove the source node.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  remove_target:
                    dependencies: []
                    description: Operation to remove a target node.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  target_changed:
                    dependencies: []
                    description: Operation to notify source some property or attribute of the target changed
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                types:
                  tosca::Configure:
                    description: The lifecycle interfaces define the essential, normative operations that each TOSCA Relationship Types may support.
                    metadata:
                      specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
                      specification.location: 5.8.5
                      tosca.canonical-name: tosca::Configure
                      tosca.normative: "true"
                    parent: tosca::Root
                  tosca::Root:
                    description: This is the default (root) TOSCA Interface Type definition that all other TOSCA Interface Types derive from.
                    metadata:
                      specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
                      specification.location: 5.8.3
                      tosca.canonical-name: tosca::Root
                      tosca.normative: "true"
            metadata: {}
            properties: {}
            types:
              tosca::HostedOn:
                description: This type represents a hosting relationship between two nodes.
                metadata:
                  role: host
                  specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
                  specification.location: 5.7.3
                  tosca.canonical-name: tosca::HostedOn
                  tosca.normative: "true"
                parent: tosca::Root
              tosca::Root:
                description: This is the default (root) TOSCA Relationship Type definition that all other TOSCA Relationship Types derive from.
                metadata:
                  specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
                  specification.location: 5.7.1
                  tosca.canonical-name: tosca::Root
                  tosca.normative: "true"
      types:
        Nginx:
          parent: tosca::WebServer
        tosca::Root:
          description: The TOSCA Root Node Type is the default type that all other TOSCA base Node Types derive from. This allows for all TOSCA nodes to have a consistent set of features for modeling and management (e.g., consistent definitions for requirements, capabilities and lifecycle interfaces).
          metadata:
            specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
            specification.location: 5.9.1
            tosca.canonical-name: tosca::Root
            tosca.normative: "true"
        tosca::SoftwareComponent:
          description: The TOSCA SoftwareComponent node represents a generic software component that can be managed and run by a TOSCA Compute Node Type.
          metadata:
            specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
            specification.location: 5.9.4
            tosca.canonical-name: tosca::SoftwareComponent
            tosca.normative: "true"
          parent: tosca::Root
        tosca::WebServer:
          description: This TOSCA WebServer Node Type represents an abstract software component or service that is capable of hosting and providing management operations for one or more WebApplication nodes.
          metadata:
            specification.citation: '[TOSCA-Simple-Profile-YAML-v1.3]'
            specification.location: 5.9.5
            tosca.canonical-name: tosca::WebServer
            tosca.normative: "true"
          parent: tosca::SoftwareComponent
    edgesOut: []
